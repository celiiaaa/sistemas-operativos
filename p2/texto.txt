else if (command_counter == 1) {
// Mandato simple
printf("Simple\n");
// Guardo el comando en el historial
if (n_elem < history_size) {
n_elem++;
} else {
printf("Free\n");
printf("Head: %d y cmd: %s\n", head, history[head].argvv[0][0]);
free_command(&history[head]);
head = (head + 1) % history_size;
}
store_command(argvv, filev, in_background, &history[tail]);
tail = (tail + 1) % history_size;

int status;
pid_t pid = fork();
switch(pid) {
case -1:    // Error
perror("Error. Fork failed.\n");
exit(-1);
case 0:     // Hijo
// Fichero de entrada
if (strcmp(filev[0], "0") != 0) {
if ((close(0)) < 0) {
perror("Error. Close failed.\n");
exit(-1);
}
if ((open(filev[0], O_RDWR, 0644)) < 0) {
perror("Error. Open failed.\n");
exit(-1);
}
}
// Fichero de salida
if (strcmp(filev[1], "0") != 0) {
if ((close(1)) < 0) {
perror("Error. Close failed.\n");
exit(-1);
}
if ((open(filev[1], O_CREAT | O_WRONLY | O_TRUNC, 0644)) < 0) {
perror("Error. Open failed.\n");
exit(-1);
}
}
// Fichero de error
if (strcmp(filev[2], "0") != 0) {
if ((close(2)) < 0) {
perror("Error. Close failed.\n");
exit(-1);
}
if ((open(filev[2], O_CREAT | O_WRONLY | O_TRUNC, 0644)) < 0) {
perror("Error. Open failed.\n");
exit(-1);
}
}

// Ejecucion del comando
if (execvp(argv_execvp[0], argv_execvp) < 0) {
perror("Error. Execvp failed.\n");
exit(-1);
}

printf("Fin proceso hijo.\n");
break;
default:    // Padre.
if (in_background) {
printf("[%d]\n", getpid());
signal(SIGCHLD, SIG_IGN);
} else {
while (wait(&status) > 0) {
perror("Error. Child execution failed.\n");
exit(-1);
}
}
break;
}